<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>2048ÊãºÂõæÊ∏∏Êàè</title>
    <script src="https://cdn.jsdelivr.net/npm/vue@3.4.27/dist/vue.global.min.js"></script>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            touch-action: manipulation;
        }
        
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: linear-gradient(135deg, #6a11cb 0%, #2575fc 100%);
            padding: 20px;
            overflow: hidden;
        }
        
        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            max-width: 480px;
            width: 100%;
            padding: 20px;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            box-shadow: 0 15px 30px rgba(0, 0, 0, 0.3);
        }
        
        .header {
            text-align: center;
            margin-bottom: 20px;
            width: 100%;
        }
        
        h1 {
            font-size: 3.5rem;
            font-weight: 700;
            color: white;
            text-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            letter-spacing: 2px;
            margin-bottom: 10px;
        }
        
        .scores-container {
            display: flex;
            justify-content: space-between;
            width: 100%;
            margin-bottom: 20px;
        }
        
        .score-box {
            background: rgba(255, 255, 255, 0.2);
            padding: 12px 20px;
            border-radius: 12px;
            text-align: center;
            min-width: 120px;
        }
        
        .score-title {
            color: #fff;
            font-size: 1rem;
            font-weight: 700;
            text-transform: uppercase;
        }
        
        .score-value {
            color: white;
            font-size: 2rem;
            font-weight: 700;
            margin-top: 4px;
        }
        
        .game-message {
            margin: 15px 0;
            padding: 10px;
            border-radius: 12px;
            background: rgba(0, 0, 0, 0.4);
            color: white;
            font-size: 1.2rem;
            font-weight: 600;
            text-align: center;
            opacity: 0;
            transition: all 0.3s ease;
        }
        
        .game-message.show {
            opacity: 1;
        }
        
        .grid-container {
            position: relative;
            width: 100%;
            aspect-ratio: 1/1; /* Á°Æ‰øùÊ≠£ÊñπÂΩ¢ */
            background: rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            margin-bottom: 20px;
            overflow: hidden;
            -webkit-user-select: none;
            user-select: none;
        }
        
        .grid {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            grid-template-rows: repeat(4, 1fr);
            gap: 12px;
            padding: 12px;
        }
        
        .grid-cell {
            background: rgba(255, 255, 255, 0.15);
            border-radius: 8px;
        }
        
        .tile {
            position: absolute;
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: 800;
            border-radius: 8px;
            transition: all 0.15s ease;
            z-index: 10;
            font-size: 1.8rem;
            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
            animation: appear 0.2s ease;
            -webkit-user-drag: none;
            user-select: none;
        }
        
        @keyframes appear {
            0% {
                transform: scale(0);
                opacity: 0;
            }
            100% {
                transform: scale(1);
                opacity: 1;
            }
        }
        
        .new-tile {
            animation: newTile 0.2s ease;
        }
        
        @keyframes newTile {
            0% { transform: scale(0.8); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }
        
        .merged-tile {
            animation: merged 0.2s ease;
        }
        
        @keyframes merged {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }
        
        .tile-2 { background: #eee4da; color: #776e65; }
        .tile-4 { background: #eee1c9; color: #776e65; }
        .tile-8 { background: #f3b27a; color: white; }
        .tile-16 { background: #f69664; color: white; }
        .tile-32 { background: #f77c5f; color: white; }
        .tile-64 { background: #f75f3b; color: white; }
        .tile-128 { background: #edd073; color: white; font-size: 1.5rem; }
        .tile-256 { background: #edcc62; color: white; font-size: 1.5rem; }
        .tile-512 { background: #edc950; color: white; font-size: 1.5rem; }
        .tile-1024 { background: #edc53f; color: white; font-size: 1.3rem; }
        .tile-2048 { background: #edc22e; color: white; font-size: 1.3rem; }
        .tile-super { background: #3c3a33; color: white; font-size: 1.1rem; }
        
        .controls {
            display: flex;
            gap: 15px;
            width: 100%;
            justify-content: center;
            margin-top: 15px;
        }
        
        button {
            padding: 14px 28px;
            font-size: 1.1rem;
            font-weight: 700;
            border: none;
            border-radius: 12px;
            background: rgba(255, 255, 255, 0.2);
            color: white;
            cursor: pointer;
            transition: all 0.2s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
            backdrop-filter: blur(5px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }
        
        button:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-3px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.3);
        }
        
        button:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        
        .instructions {
            margin-top: 25px;
            text-align: center;
            color: rgba(255, 255, 255, 0.85);
            font-size: 1rem;
            line-height: 1.6;
            max-width: 80%;
        }
        
        .swipe-hint {
            display: none;
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255, 255, 255, 0.7);
            font-size: 0.9rem;
        }
        
        @media (hover: none) {
            .swipe-hint {
                display: block;
            }
        }
        
        @media (max-width: 500px) {
            .header h1 {
                font-size: 3rem;
            }
            
            .score-box {
                padding: 10px 15px;
                min-width: 100px;
            }
            
            .score-value {
                font-size: 1.8rem;
            }
            
            .tile {
                font-size: 1.5rem;
            }
            
            .tile-128, .tile-256, .tile-512 {
                font-size: 1.2rem;
            }
            
            .tile-1024, .tile-2048 {
                font-size: 1rem;
            }
            
            button {
                padding: 12px 20px;
                font-size: 1rem;
            }
            
            .instructions p {
                font-size: 0.9rem;
            }
        }
    </style>
</head>
<body>
    <div id="app">
        <div class="game-container">
            <div class="header">
                <h1>2048</h1>
            </div>
            
            <div class="scores-container">
                <div class="score-box">
                    <div class="score-title">ÂàÜÊï∞</div>
                    <div class="score-value">{{ score }}</div>
                </div>
                
                <div class="score-box">
                    <div class="score-title">ÊúÄÈ´òÂàÜ</div>
                    <div class="score-value">{{ highScore }}</div>
                </div>
            </div>
            
            <div class="game-message" :class="{ show: hasWon || gameOver }">
                <p v-if="hasWon">ÊÅ≠ÂñúÔºÅ‰Ω†Ëµ¢‰∫ÜÔºÅüéâ</p>
                <p v-else-if="gameOver">Ê∏∏ÊàèÁªìÊùü üò¢</p>
                <p v-else>{{ message }}</p>
            </div>
            
            <div 
                class="grid-container"
                @touchstart="touchStart"
                @touchmove.prevent="touchMove"
                @touchend="touchEnd"
            >
                <div class="swipe-hint">ÊªëÂä®Â±èÂπïÁßªÂä®ÊñπÂùó</div>
                <div class="grid">
                    <template v-for="row in boardSize" :key="row">
                        <div 
                            v-for="col in boardSize" 
                            :key="col" 
                            class="grid-cell"
                        ></div>
                    </template>
                </div>
                <div class="tiles-container">
                    <div 
                        v-for="tile in tiles" 
                        :key="tile.id"
                        :class="['tile', 'tile-' + tile.value, { 'new-tile': tile.new, 'merged-tile': tile.merged }]"
                        :style="{
                            width: tileSize + 'px',
                            height: tileSize + 'px',
                            top: (tile.y * (tileSize + gap) + gridOffset) + 'px',
                            left: (tile.x * (tileSize + gap) + gridOffset) + 'px',
                            zIndex: tile.value,
                            'font-size': fontScale(tile.value) + 'rem'
                        }"
                    >
                        {{ tile.value }}
                    </div>
                </div>
            </div>
            
            <div class="controls">
                <button @click="resetGame">Êñ∞Ê∏∏Êàè</button>
                <button @click="undoMove">ÊÇîÊ£ã</button>
            </div>
            
            <div class="instructions">
                <p>‰ΩøÁî®ÈîÆÁõò <strong>‚Üê ‚Üë ‚Üí ‚Üì</strong> ÊñπÂêëÈîÆÊàñ<strong>Ëß¶Êë∏ÊªëÂä®</strong>ÁßªÂä®ÊñπÂùó<br>ÂΩì‰∏§‰∏™Áõ∏ÂêåÊï∞Â≠óÁöÑÊñπÂùóÁ¢∞ÊíûÊó∂ÔºåÂÆÉ‰ª¨‰ºöÂêàÂπ∂ÊàêÂÆÉ‰ª¨ÁöÑÂíåÔºÅ</p>
            </div>
        </div>
    </div>

    <script>
        const { createApp, ref, reactive, computed, onMounted, onUnmounted } = Vue;
        
        createApp({
            setup() {
                const boardSize = 4;
                const gap = 12; // ÊñπÊ†ºÈó¥Ë∑ù
                const gridOffset = 12; // ÂÜÖËæπË∑ù
                
                const tiles = reactive([]);
                const score = ref(0);
                const highScore = ref(0);
                const hasWon = ref(false);
                const gameOver = ref(false);
                const message = ref("");
                const prevBoardState = ref([]);
                const tileSize = ref(80);
                
                // Ëß¶Â±èÊéßÂà∂ÂèòÈáè
                const touchStartX = ref(0);
                const touchStartY = ref(0);
                const touchEndX = ref(0);
                const touchEndY = ref(0);
                
                const generateId = () => Date.now() + Math.random().toString(36).substring(2, 9);
                
                // ËÆ°ÁÆóÂêàÈÄÇÁöÑÊñπÂùóÂ∞∫ÂØ∏
                const calculateTileSize = () => {
                    const container = document.querySelector('.grid-container');
                    if (!container) return 80;
                    
                    // Ëé∑ÂèñÂÆπÂô®Â∞∫ÂØ∏
                    const containerWidth = container.offsetWidth;
                    
                    // ËÆ°ÁÆóÂèØÁî®Á©∫Èó¥ (ÂáèÂéªÂÜÖËæπË∑ùÂíåÈó¥Ë∑ù)
                    const availableWidth = containerWidth - (2 * gridOffset) - ((boardSize - 1) * gap);
                    
                    // ËÆ°ÁÆóÊØè‰∏™ÊñπÂùóÁöÑÂ∞∫ÂØ∏
                    return availableWidth / boardSize;
                };
                
                // Â≠ó‰ΩìÂ§ßÂ∞èÁº©Êîæ
                const fontScale = (value) => {
                    if (value <= 64) return 1.8;
                    if (value <= 512) return 1.5;
                    if (value <= 2048) return 1.3;
                    return 1.1;
                };
                
                // Ê∑ªÂä†Êñ∞ÊñπÂùó
                const addNewTile = (value = Math.random() > 0.8 ? 4 : 2) => {
                    const emptyCells = [];
                    
                    // ÊâæÂà∞ÊâÄÊúâÁ©∫ÂçïÂÖÉÊ†º
                    for (let y = 0; y < boardSize; y++) {
                        for (let x = 0; x < boardSize; x++) {
                            if (!tiles.some(tile => tile.x === x && tile.y === y)) {
                                emptyCells.push({x, y});
                            }
                        }
                    }
                    
                    if (emptyCells.length > 0) {
                        const cell = emptyCells[Math.floor(Math.random() * emptyCells.length)];
                        tiles.push({
                            id: generateId(),
                            value: value,
                            x: cell.x,
                            y: cell.y,
                            new: true,
                            merged: false
                        });
                        
                        setTimeout(() => {
                            const newTile = tiles.find(t => t.id === tiles[tiles.length - 1].id);
                            if (newTile) newTile.new = false;
                        }, 200);
                    }
                    
                    return emptyCells.length > 0;
                };
                
                // ÈáçÁΩÆÊ∏∏Êàè
                const resetGame = () => {
                    tiles.splice(0, tiles.length);
                    score.value = 0;
                    hasWon.value = false;
                    gameOver.value = false;
                    message.value = "";
                    
                    // Ê∑ªÂä†ÂàùÂßã‰∏§‰∏™ÊñπÂùó
                    addNewTile();
                    addNewTile();
                    
                    // Êõ¥Êñ∞Êú¨Âú∞Â≠òÂÇ®ÊúÄÈ´òÂàÜ
                    try {
                        localStorage.setItem('2048_high_score', highScore.value.toString());
                    } catch (e) {
                        console.log("‰øùÂ≠òÊúÄÈ´òÂàÜÂ§±Ë¥•:", e);
                    }
                };
                
                // ‰øùÂ≠òÊ∏∏ÊàèÁä∂ÊÄÅ
                const saveBoardState = () => {
                    prevBoardState.value = JSON.parse(JSON.stringify(tiles));
                };
                
                // ÊÇîÊ£ãÂäüËÉΩ
                const undoMove = () => {
                    if (prevBoardState.value.length) {
                        tiles.splice(0, tiles.length, ...prevBoardState.value.map(tile => ({
                            ...tile,
                            merged: false,
                            new: false
                        })));
                        
                        // ÁßªÈô§ÊúÄÂêé‰∏Ä‰∏™ÊñπÂùóÔºàÊ∏∏ÊàèÁªìÊùüÊó∂Ê∑ªÂä†ÁöÑÔºâ
                        if (gameOver.value && tiles.length > prevBoardState.value.length) {
                            tiles.pop();
                        }
                        
                        gameOver.value = false;
                        hasWon.value = false;
                        message.value = "";
                    }
                };
                
                // Ê£ÄÊü•ÊòØÂê¶ËÉΩÁßªÂä®
                const canMove = () => {
                    // Ê£ÄÊü•ÊòØÂê¶ËøòÊúâÁ©∫‰Ωç
                    for (let y = 0; y < boardSize; y++) {
                        for (let x = 0; x < boardSize; x++) {
                            if (!tiles.some(tile => tile.x === x && tile.y === y)) {
                                return true;
                            }
                        }
                    }
                    
                    // Ê£ÄÊü•ÊòØÂê¶ËøòËÉΩÂêàÂπ∂
                    for (let y = 0; y < boardSize; y++) {
                        for (let x = 0; x < boardSize; x++) {
                            const tile = tiles.find(t => t.x === x && t.y === y);
                            if (tile) {
                                const neighbors = [
                                    {x: x + 1, y},
                                    {x: x - 1, y},
                                    {x, y: y + 1},
                                    {x, y: y - 1}
                                ];
                                
                                for (const neighbor of neighbors) {
                                    if (neighbor.x >= 0 && neighbor.x < boardSize && neighbor.y >= 0 && neighbor.y < boardSize) {
                                        const neighborTile = tiles.find(t => t.x === neighbor.x && t.y === neighbor.y);
                                        if (neighborTile && neighborTile.value === tile.value) {
                                            return true;
                                        }
                                    }
                                }
                            }
                        }
                    }
                    
                    return false;
                };
                
                // ÁßªÂä®ÊñπÂùó
                const move = (direction) => {
                    if (gameOver.value) return;
                    
                    saveBoardState();
                    
                    let moved = false;
                    const positions = calculatePositions(direction);
                    
                    // Ê∏ÖÈô§ÂêàÂπ∂Ê†áËÆ∞
                    tiles.forEach(tile => tile.merged = false);
                    
                    // ÊåâË°å/ÂàóÈ°∫Â∫èÂ§ÑÁêÜ
                    positions.order.forEach(index => {
                        const line = tiles.filter(tile => positions.getKey(tile) === index);
                        line.sort((a, b) => positions.sort(a, b));
                        
                        let pos = positions.start;
                        let prevTile = null;
                        
                        for (const tile of line) {
                            // Ê£ÄÊü•ÊòØÂê¶ÂèØÂêàÂπ∂
                            if (prevTile && prevTile.value === tile.value && !prevTile.merged) {
                                prevTile.value += tile.value;
                                prevTile.merged = true;
                                
                                // Êõ¥Êñ∞ÂàÜÊï∞
                                score.value += prevTile.value;
                                
                                // Êõ¥Êñ∞ÊúÄÈ´òÂàÜ
                                if (score.value > highScore.value) {
                                    highScore.value = score.value;
                                    try {
                                        localStorage.setItem('2048_high_score', highScore.value.toString());
                                    } catch (e) {
                                        console.log("‰øùÂ≠òÊúÄÈ´òÂàÜÂ§±Ë¥•:", e);
                                    }
                                }
                                
                                // Ê£ÄÊü•ÊòØÂê¶Ëé∑ËÉú
                                if (prevTile.value === 2048 && !hasWon.value) {
                                    hasWon.value = true;
                                    message.value = "‰Ω†Ëµ¢‰∫ÜÔºÅÁªßÁª≠ÊåëÊàòÊõ¥È´òÂàÜÂêßÔºÅ";
                                }
                                
                                // ÁßªÈô§ÂΩìÂâçÊñπÂùó
                                const tileIndex = tiles.indexOf(tile);
                                tiles.splice(tileIndex, 1);
                                moved = true;
                            } else {
                                if (positions.getValue(tile) !== pos) moved = true;
                                positions.setValue(tile, pos);
                                prevTile = tile;
                                pos += positions.step;
                            }
                        }
                    });
                    
                    if (moved) {
                        // Ê∑ªÂä†Êñ∞ÊñπÂùó
                        const added = addNewTile();
                        
                        // Ê£ÄÊü•Ê∏∏ÊàèÊòØÂê¶ÁªìÊùü
                        if (!added && !canMove()) {
                            gameOver.value = true;
                            message.value = "Ê∏∏ÊàèÁªìÊùüÔºåÊó†Ê≥ïÁßªÂä®‰∫ÜÔºÅ";
                        }
                    }
                };
                
                // ÊñπÂêëËÆ°ÁÆóÈÄªËæë
                const calculatePositions = (direction) => {
                    const operations = {
                        left: {
                            getKey: (tile) => tile.y,
                            getValue: (tile) => tile.x,
                            setValue: (tile, value) => tile.x = value,
                            sort: (a, b) => a.x - b.x,
                            start: 0,
                            step: 1,
                            order: [0, 1, 2, 3]
                        },
                        right: {
                            getKey: (tile) => tile.y,
                            getValue: (tile) => tile.x,
                            setValue: (tile, value) => tile.x = value,
                            sort: (a, b) => b.x - a.x,
                            start: 3,
                            step: -1,
                            order: [0, 1, 2, 3]
                        },
                        up: {
                            getKey: (tile) => tile.x,
                            getValue: (tile) => tile.y,
                            setValue: (tile, value) => tile.y = value,
                            sort: (a, b) => a.y - b.y,
                            start: 0,
                            step: 1,
                            order: [0, 1, 2, 3]
                        },
                        down: {
                            getKey: (tile) => tile.x,
                            getValue: (tile) => tile.y,
                            setValue: (tile, value) => tile.y = value,
                            sort: (a, b) => b.y - a.y,
                            start: 3,
                            step: -1,
                            order: [0, 1, 2, 3]
                        }
                    };
                    
                    return operations[direction];
                };
                
                // Â§ÑÁêÜÈîÆÁõòËæìÂÖ•
                const handleKeyDown = (e) => {
                    switch (e.key) {
                        case 'ArrowUp':
                            move('up');
                            e.preventDefault();
                            break;
                        case 'ArrowDown':
                            move('down');
                            e.preventDefault();
                            break;
                        case 'ArrowLeft':
                            move('left');
                            e.preventDefault();
                            break;
                        case 'ArrowRight':
                            move('right');
                            e.preventDefault();
                            break;
                        case 'r': case 'R': // Ê∑ªÂä†ÈáçÁΩÆÂø´Êç∑ÈîÆ
                            resetGame();
                            break;
                    }
                };
                
                // Â§ÑÁêÜËß¶Â±è‰∫ã‰ª∂
                const touchStart = (e) => {
                    const touch = e.touches[0];
                    touchStartX.value = touch.clientX;
                    touchStartY.value = touch.clientY;
                };
                
                const touchMove = (e) => {
                    e.preventDefault();
                };
                
                const touchEnd = (e) => {
                    const touch = e.changedTouches[0];
                    touchEndX.value = touch.clientX;
                    touchEndY.value = touch.clientY;
                    
                    handleTouchMove();
                };
                
                // ËÆ°ÁÆóËß¶Êë∏ÊñπÂêë
                const handleTouchMove = () => {
                    const dx = touchEndX.value - touchStartX.value;
                    const dy = touchEndY.value - touchStartY.value;
                    const absDx = Math.abs(dx);
                    const absDy = Math.abs(dy);
                    
                    // ÊúÄÂ∞èÊªëÂä®ÈòàÂÄº
                    if (Math.max(absDx, absDy) < 30) return;
                    
                    if (absDx > absDy) {
                        if (dx > 0) move('right');
                        else move('left');
                    } else {
                        if (dy > 0) move('down');
                        else move('up');
                    }
                };
                
                // Á™óÂè£Â§ßÂ∞èÂèòÂåñÊó∂ÈáçÊñ∞ËÆ°ÁÆóÊñπÂùóÂ∞∫ÂØ∏
                const handleResize = () => {
                    tileSize.value = calculateTileSize();
                };
                
                // ÁªÑ‰ª∂ÊåÇËΩΩÊó∂
                onMounted(() => {
                    // ÂàùÂßãÂåñÂ∞∫ÂØ∏
                    tileSize.value = calculateTileSize();
                    
                    // ÁõëÂê¨Á™óÂè£ÂèòÂåñ
                    window.addEventListener('resize', handleResize);
                    
                    // ÁõëÂê¨ÈîÆÁõò‰∫ã‰ª∂
                    window.addEventListener('keydown', handleKeyDown);
                    
                    // Â∞ùËØï‰ªélocalStorageÂä†ËΩΩÊúÄÈ´òÂàÜ
                    try {
                        const savedHighScore = localStorage.getItem('2048_high_score');
                        if (savedHighScore) {
                            highScore.value = parseInt(savedHighScore);
                        }
                    } catch (e) {
                        console.log("Âä†ËΩΩÊúÄÈ´òÂàÜÂ§±Ë¥•:", e);
                    }
                    
                    // ÂàùÂßãÂåñÊ∏∏Êàè
                    resetGame();
                });
                
                // ÁªÑ‰ª∂Âç∏ËΩΩÊó∂
                onUnmounted(() => {
                    window.removeEventListener('resize', handleResize);
                    window.removeEventListener('keydown', handleKeyDown);
                });
                
                return {
                    boardSize,
                    tileSize,
                    tiles,
                    score,
                    highScore,
                    hasWon,
                    gameOver,
                    message,
                    gap,
                    gridOffset,
                    resetGame,
                    undoMove,
                    touchStart,
                    touchMove,
                    touchEnd,
                    fontScale
                };
            }
        }).mount('#app');
    </script>
</body>
</html>